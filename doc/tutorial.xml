<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
               "docbook/dtd/xml/4.2/docbookx.dtd">

<article>
  <articleinfo>
    <title>Getting started with LELA</title>
    <copyright>
      <year>2011</year>
      <holder>Bradford Hovinen</holder>
    </copyright>
  </articleinfo>
  <section>
    <title>Downloading and installing</title>

    <para>
      The latest release of LELA may be obtained from
      its <ulink url="http://www.singular.uni-kl.de/lela/">website</ulink>. Developement
      of LELA occurs at
      its <ulink url="https://github.com/hovinen/LELA">GIT
      repository</ulink> to which anyone may obtain read-only access.
    </para>

    <para>
      See the file INSTALL in the LELA-distribution for detailed
      installation-instructions. The basic procedure is
      <programlisting>
./configure
make
make install</programlisting>
    </para>

    <para>
      LELA has one mandatory library-dependency, the GNU
      Multi-Precision Library (GMP) for calculations with large
      integers and rational numbers. This is available for nearly all
      platforms and can usually be obtained from your platform-vendor
      or, for users of Windows,
      from <ulink url="http://www.cygwin.com/">Cygwin</ulink>. See
      also GMP's <ulink url="http://gmplib.org/">website</ulink>.
    </para>

    <para>
      In addition, LELA can optionally make use of some libraries to
      provide highly tuned implementations of algorithms in specific
      cases or to provide additional functionality. Their presence is
      detected when you run <filename>configure</filename>. They are
      as follows:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  The <emphasis>Basic Linear Algebra Subprograms</emphasis>
	  or <emphasis>BLAS</emphasis>. This can dramatically improve
	  performance over Z/n. LELA can use almost any implementation
	  of BLAS. Such an implementation can be obtained from your
	  vendor or from a project such
	  as <ulink url="http://math-atlas.sourceforge.net/">ATLAS</ulink>.
	</para>
	<para>
	  The use of BLAS may be enabled or disabled when
	  running <filename>configure</filename> with the
	  option <literal>--with-blas</literal>,
	  respectively <literal>--without-blas</literal>.
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>M4RI</emphasis>. This library dramatically
	  improves performance for calculations with dense matrices
	  over GF(2). It can be obtained
	  from <ulink url="http://m4ri.sagemath.org/">its
	  website</ulink>.
	</para>
	<para>
	  The use of M4RI may be enabled or disabled when
	  running <filename>configure</filename> with the
	  option <literal>--with-m4ri</literal>,
	  respectively <literal>--without-m4ri</literal>.
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>libpng</emphasis>. This library adds support for
	  reading and writing 0-1 matrices in PNG format, which is
	  extremely useful for large matrices.
	</para>
	<para>
	  The use of libpng may be enabled or disabled when
	  running <filename>configure</filename> with the
	  option <literal>--with-png</literal>,
	  respectively <literal>--without-png</literal>.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      For a complete list of options
      to <filename>configure</filename>, run
      <programlisting>
./configure --help</programlisting>
    </para>
  </section>
  <section>
    <title>Basic usage</title>

    <para>
      In this section you will learn how to use LELA for basic
      calculations.
    </para>

    <section>
      <title>Generalities</title>

      <para>
	LELA is a library in C++ which is intended for exact
	calculations in linear algebra. It is flexible in two
	respects:
      </para>

      <itemizedlist>
	<listitem>
	  <simpara>the choice of ring over which vectors and matrices are defined, and</simpara>
	</listitem>
	<listitem>
	  <simpara>the representation of those vectors or matrices, e.g. dense versus sparse.</simpara>
	</listitem>
      </itemizedlist>

      <para>
	LELA is designed so that it will use the most efficient
	available method for the above choices. To that end, various
	algorithms are implemented for different cases and selected
	automatically at compile-time. There are also wrappers for
	certain libraries which contain specialised implementations
	for specific cases, such as M4RI for dense matrices over
	GF(2).
      </para>

      <para>
	LELA is a C++ template-library. This means in particular that
	algorithms and classes which require arithmetic are
	parametrised by the ring of computation as well as vector- and
	matrix-types. Many functions are then specialised to provide
	better performance in specific cases, for example a specific
	choice of vector-representation over a specific ring. It is
	possible to extend the functionality of LELA by providing
	types which meet well-defined interfaces (see Section 3).
      </para>

      <para>
	All definitions in LELA are in the
	namespace <type>LELA</type>. A simple program using LELA may
	include the line <type>using namespace LELA;</type> at the
	top of the file to avoid unneeded verbage.
      </para>

      <para>
	The basic types with which the user should be familiar are:
      </para>

      <itemizedlist>
	<listitem>
	  <simpara><emphasis>Rings</emphasis>, which provide
	    ring-arithmetic;</simpara>
	</listitem>
	<listitem>
	  <simpara><emphasis>Ring-elements</emphasis>, the type of
	which is defined by the ring;</simpara>
	</listitem>
	<listitem>
	  <simpara><emphasis>Vectors in a free module over a
	    ring;</emphasis></simpara>
	</listitem>
	<listitem>
	  <simpara><emphasis>Matrices over a ring;</emphasis></simpara>
	</listitem>
	<listitem>
	  <simpara><emphasis>Context-objects</emphasis>, which allow the
	    matrix-arithmetic to be configured;</simpara>
	</listitem>
	<listitem>
	  <simpara><emphasis>Solution-objects</emphasis>, which provide a
	    simple interface to the more sophisticated algorithms, such
	    as computing the reduced row-echelon form of a matrix.</simpara>
	</listitem>
      </itemizedlist>

      <para>
	This section is divided as follows. First there are
	instructions on how to define rings followed by some basics on
	arithmetic over rings. Then the definition of vectors and
	matrices is described. Then the facilities for vector- and
	matrix-arithmetic are introduced. After that, a
	solution-object for a higher-level interface is briefly
	described. Then one learns how to input and output vectors and
	matrices to and from the console and files. Then there is some
	information on support for reporting, benchmarking, and
	debugging in LELA. Finally, we present some pointers on how to
	deal with compiler-errors which sometimes arise.
      </para>
    </section>

    <section>
      <title>Selecting the ring</title>

      <para>
	The first step is to define the ring over which you wish to
	compute. You must include the ring's corresponding header-file
	and then declare the ring-object. There are four ring-types
	built in to LELA:
      </para>

      <itemizedlist>
	<listitem>
	  <simpara><type>Integers</type>, for integers (actually a
	    wrapper for GMP)</simpara>
	</listitem>
	<listitem>
	  <simpara><type>Rationals</type>, for rational numbers (also a
	    wrapper for GMP)</simpara>
	</listitem>
	<listitem>
	  <simpara><type>Modular</type>, for integers modulo n,</simpara>
	</listitem>
	<listitem>
	  <simpara><type>GF2</type> (for fast computations over GF(2)),
	    and</simpara>
	</listitem>
	<listitem>
	  <simpara><type>TypeWrapperRing</type> (a wrapper around any
	    type which implements the basic arithmetic-operations +, -, *,
	    /, and %)</simpara>
	</listitem>
      </itemizedlist>

      <section>
	<title><type>Integers</type></title>

	<para>
	  To work with integers (of arbitrary precision), use the following:
	</para>

	<programlisting>
#include &lt;lela/ring/integers.h&gt;

using namespace LELA;

int main ()
{
	Integers Z;
	...
	return 0;
}</programlisting>

	<para>
	  The element-type of <type>Integers</type> is called
	  <type>integer</type>. It is defined in
	  <filename>lela/integer.h</filename>.
	</para>
      </section>

      <section>
	<title><type>Rationals</type></title>

	<para>
	  To work with rational numbers, use the following:
	</para>

	<programlisting>
#include &lt;lela/ring/rationals.h&gt;

using namespace LELA;

int main ()
{
	Rationals F;
	...
	return 0;
}</programlisting>

	<para>
	  The element-type of <type>Rationals</type> is
	  called <type>RationalElement</type>. It is defined
	  in <filename>lela/element/rational.h</filename>.
	</para>
      </section>

      <section>
	<title><type>Modular</type></title>

	<para>
	  Here is an example of the declaration of the field of
	  integers modulo 101:
	</para>

	<programlisting>
#include &lt;lela/integer.h&gt;
#include &lt;lela/ring/modular.h&gt;

using namespace LELA;

int main ()
{
	Modular&lt;uint8&gt; F (101);
	...
	return 0;
}</programlisting>

	<para>
	  The type <type>Modular</type> is parametrised by the
	  element-type, which may in principle be any C++-type which
	  supports basic arithmetic operations (i.e. binary +, -, *,
	  /, and %). The parameter passed to the constructor is the
	  modulus. It may not exceed the maximum value allowed by the
	  type.
	</para>

	<para>
	  The choice of which element-type to use is based on the size
	  of the modulus (since obviously some moduli are too big for
	  some element-types) as well as whether one wishes to use an
	  integral of a floating-point representation. A
	  floating-point representation generally uses more memory for
	  the same modulus but enables the use of highly tuned
	  BLAS-implementations which can greatly improve performance
	  as compared with the integral representation.
	</para>

	<para>
	  While with a given element-type one can use any modulus up
	  to the maximum (see table below), we recommend using a
	  somewhat larger element-type than is necessary, since this
	  can improve performance greatly. Here we present some
	  recommendations.
	</para>

	<table>
	  <title>Element-types to be used with <type>Modular</type></title>
	  <tgroup cols='5' align='left' colsep='1' rowsep='1'>
	    <colspec colname='type'/>
	    <colspec colname='size'/>
	    <colspec colname='int'/>
	    <colspec colname='maxallowed'/>
	    <colspec colname='maxrec'/>
	    <thead>
	      <row>
		<entry>Element-type</entry>
		<entry>Size</entry>
		<entry>Integral vs. FP</entry>
		<entry>Maximum allowed modulus</entry>
		<entry>Maximum recommended modulus</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>uint8</entry>
		<entry>1 byte</entry>
		<entry>Integral</entry>
		<entry>255 (2<superscript>8</superscript>-1)</entry>
		<entry>255</entry>
	      </row>
	      <row>
		<entry>uint16</entry>
		<entry>2 bytes</entry>
		<entry>Integral</entry>
		<entry>65535 (2<superscript>16</superscript>-1)</entry>
		<entry>65535</entry>
	      </row>
	      <row>
		<entry>uint32</entry>
		<entry>4 bytes</entry>
		<entry>Integral</entry>
		<entry>4294967295 (2<superscript>32</superscript>-1)</entry>
		<entry>4294967295</entry>
	      </row>
	      <row>
		<entry>float</entry>
		<entry>4 bytes</entry>
		<entry>Floating point</entry>
		<entry>4095 (2<superscript>12</superscript>-1)</entry>
		<entry>127</entry>
	      </row>
	      <row>
		<entry>double</entry>
		<entry>8 bytes</entry>
		<entry>Floating point</entry>
		<entry>67108863 (2<superscript>26</superscript>-1)</entry>
		<entry>2097151</entry>
	      </row>
	      <row>
		<entry>integer</entry>
		<entry>Variable</entry>
		<entry>Integral</entry>
		<entry>Unlimited</entry>
		<entry>Unlimited</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>
	  The definitions of the types above (other than float and
	  double) are in <filename>lela/integer.h</filename>. The
	  header-file <filename>lela/ring/modular.h</filename>
	  declares the class <type>Modular</type>.
	</para>
      </section>

      <section>
	<title><type>GF2</type></title>

	<para>
	  The following code permits working over GF2:
	</para>

	<programlisting>
#include &lt;lela/ring/gf2.h&gt;

using namespace LELA;

int main ()
{
	GF2 F;
	...
	return 0;
}</programlisting>

	<para>
	  It is also possible to work over GF(2) using
	  the <type>Modular</type> class described above, but the
	  specialised class GF2 is vastly more efficient. Its use is
	  highly recommended.
	</para>

	<para>
	  The element-type of <type>GF2</type>
	  is <type>bool</type>. The value <literal>true</literal>
	  corresponds to the field-element 1
	  and <literal>false</literal> to 0.
	</para>
      </section>

      <section>
	<title><type>TypeWrapperRing</type></title>

	<para>
	  If desired, it is possible to wrap a C++-type (builtin or
	  user-defined) which supports standard arithmetic into
	  LELA-ring so that it may be used within LELA. For example,
	  wrapping <type>float</type> or <type>double</type> permits
	  that LELA be used for numerical linear algebra. To do this,
	  use the following;
	</para>

	<programlisting>
#include &lt;lela/ring/unparametric.h&gt;

using namespace LELA;

int main ()
{
	TypeWrapperRing&lt;float&gt; R;
	...
	return 0;
}</programlisting>

	<para>
	  The class <type>TypeWrapperRing</type> is parametrised by
	  the type being wrapped, which is then the element-type of
	  the resulting ring.
	</para>
      </section>

      <section>
	<title>Ring-arithmetic</title>

	<para>
	  Once a ring is declared, it may be used to perform arithmetic:
	</para>

	<programlisting>
#include &lt;iostream&gt;
#include &lt;lela/integer.h&gt;
#include &lt;lela/ring/modular.h&gt;

using namespace LELA;

int main ()
{
	Modular&lt;uint8&gt; F (101);

	uint8 a, b, c, d; // Declare ring-elements
	F.init (a, -1);   // Set a to -1 in the ring
	F.init (b, 1);    // Set b to 1 in the ring
	F.add (c, a, b);  // Set c &lt;- a + b
	F.sub (c, a, b);  // Set c &lt;- a - b
	F.mul (c, a, b);  // Set c &lt;- a * b
	F.neg (c, b);     // Set c &lt;- -b

	F.axpy (d, a, b, c);  // Set d &lt;- a * b + c

	if (F.inv (c, a)) // Is a invertible in the ring? If so, set c to the inverse
		std::cout &lt;&lt; "a is invertible" &lt;&lt; std::endl;
	else
		std::cout &lt;&lt; "a is not invertible" &lt;&lt; std::endl;

	if (F.div (c, a, b)) // Does the quotient a / b exist in the ring? If so, set c to the quotient
		std::cout &lt;&lt; "a / b exists" &lt;&lt; std::endl;
	else
		std::cout &lt;&lt; "a / b does not exist" &lt;&lt; std::endl;

	return 0;
}</programlisting>

	<para>
	  All arithmetic operations take a reference to the element in
	  which to write the result as their first parameter. As
	  compared with the seemingly more natural approach of
	  returning the result, this makes things more efficient in
	  the case that the element-type is complicated (such as a
	  GMP-integer).
	</para>

	<para>
	  The method <function>init</function> sets its first argument
	  to the ring-element which is the image of its second
	  argument under the canonical map from the integers to the
	  ring. The second argument may be of any integral type.
	</para>

	<para>
	  All arithmetic-operations have in-place variants:
	</para>

	<programlisting>
#include &lt;lela/integer.h&gt;
#include &lt;lela/ring/modular.h&gt;

using namespace LELA;

int main ()
{
	Modular&lt;uint8&gt; F (101);

	uint8 a, b, c, d; // Declare ring-elements
	F.init (a, -1);   // Set a to -1 in the ring
	F.copy (b, a);    // Copy a to b
	F.negin (b);      // Replace b to -b
	F.init (c, 2);    // Set c to 2 in the ring
	F.addin (a, b);   // Set a &lt;- a + b
	F.subin (a, b);   // Set a &lt;- a - b
	F.mulin (a, b);   // Set a &lt;- a * b

	F.axpyin (a, b, c);  // Set a &lt;- a + b * c

	if (F.invin (a)) // Is a invertible in the ring? If so, replace it with its inverse
		std::cout &lt;&lt; "a is invertible" &lt;&lt; std::endl;
	else
		std::cout &lt;&lt; "a is not invertible" &lt;&lt; std::endl;

	if (F.divin (a, b)) // Does the quotient a / b exist in the ring? If so, replace a by a / b
		std::cout &lt;&lt; "a / b exists" &lt;&lt; std::endl;
	else
		std::cout &lt;&lt; "a / b does not exist" &lt;&lt; std::endl;

	return 0;
}</programlisting>

	<para>
	  The method <function>copy</function> makes a copy of its
	  second argument and stores it in its first argument. In
	  generic code, it is recommended to use
	  <function>copy</function> rather than the
	  assignment-operator, since the latter may result in only a
	  shallow copy, depending on the element-type. In the case of
	  <type>Modular&lt;uint8&gt;</type> above, the call
	  <literal>copy (b, a)</literal> is entirely equivalent to the
	  assignment <literal>b = a</literal>.
	</para>

	<para>
	  Ring-elements may be read from or written to a C++-stream
	  with the methods <function>read</function> and <function>write</function>:
	</para>

	<programlisting>
#include &lt;lela/integer.h&gt;
#include &lt;lela/ring/modular.h&gt;

using namespace LELA;

int main ()
{
	Modular&lt;uint8&gt; F (101);

	uint8 a;

	std::cout &lt;&lt; "Enter a value: ";
	F.read (std::cin, a);

	std::cout &lt;&lt; "You entered ";
	F.write (std::cout, a) &lt;&lt; std::endl;

	return 0;
}</programlisting>

	<para>
	  The precise meaning of these methods depends on the
	  ring. The method <type>Modular::read</type> interprets the
	  input as an integer and maps it to the modular field under
	  the canonical homomorphism.
	</para>

	<para>
	  Equality of elements may be checked with the
	  method <function>areEqual</function>:
	</para>

	<programlisting>
#include &lt;lela/integer.h&gt;
#include &lt;lela/ring/modular.h&gt;

using namespace LELA;

int main ()
{
	Modular&lt;uint8&gt; F (101);

	uint8 a, b;

	F.init (a, 50);

	std::cout &lt;&lt; "Enter a value: ";
	F.read (std::cin, b);

	if (F.areEqual (a, b))
		std::cout &lt;&lt; "You guessed correctly!" &lt;&lt; std::endl;

	return 0;
}</programlisting>

	<para>
	  Similarly, the methods <function>isZero</function>
	  and <function>isOne</function> determine whether a
	  ring-element is equal to zero or one, respectively, in the
	  ring.
	</para>

	<programlisting>
#include &lt;lela/integer.h&gt;
#include &lt;lela/ring/modular.h&gt;

using namespace LELA;

int main ()
{
	Modular&lt;uint8&gt; F (101);

	uint8 a;

	std::cout &lt;&lt; "Enter a value: ";
	F.read (std::cin, a);

	if (F.isZero (a))
		std::cout &lt;&lt; "You entered zero in the ring" &lt;&lt; std::endl;
	if (F.isOne (a))
		std::cout &lt;&lt; "You entered one in the ring" &lt;&lt; std::endl;

	return 0;
}</programlisting>

	<para>
	  The
	  methods <function>zero</function>, <function>one</function>,
	  and <function>minusOne</function> return read-only
	  references to respectively the ring's 0, 1, and -1 elements.
	</para>

	<programlisting>
#include &lt;lela/integer.h&gt;
#include &lt;lela/ring/modular.h&gt;

using namespace LELA;

int main ()
{
	Modular&lt;uint8&gt; F (101);

	uint8 a;

	std::cout &lt;&lt; "Enter a value: ";
	F.read (std::cin, a);

	if (F.areEqual (a, F.one ()))
		std::cout &lt;&lt; "You entered one in the ring" &lt;&lt; std::endl;
	if (F.areEqual (a, F.zero ()))
		std::cout &lt;&lt; "You entered zero in the ring" &lt;&lt; std::endl;
	if (F.areEqual (a, F.minusOne ()))
		std::cout &lt;&lt; "You entered minus one in the ring" &lt;&lt; std::endl;

	return 0;
}</programlisting>

	<para>
	  When writing algorithms, it is desireable that the code not
	  depend on operating over a given ring. Thus the relevant
	  function or class should be parametrised on the
	  ring-type. Ring-elements may be declared with <type>typename
	  Ring::Element</type>, as in the following:
	</para>

	<programlisting>
template &lt;class Ring&gt;
void MyAlgorithm (const Ring &amp;R, typename Ring::Element &amp;v)
{
	typename Ring::Element a, b;

	R.init (a, 1);
	R.init (b, 103);
	R.add (v, a, b);
}</programlisting>
      </section>
    </section>
    <section>
      <title>Declaring and filling vectors and matrices</title>

      <para>
	Algorithms in LELA are designed to be generic with respect to
	vector- and matrix-type. They may also work with both sparse
	and dense representations. There is a variety of vector- and
	matrix-types to serve these needs.
      </para>

      <section>
	<title>Types of vectors</title>

	<para>
	  LELA supports five basic vector representation-types: two
	  for general rings and three over GF(2). Any C++-type which
	  meets the required interface of one of these types can be
	  used in any container or algorithm which accepts that type.
	</para>

	<section>
	  <title>Representation-types for general rings</title>

	  <para>
	    Over general rings the two vector representation-types are
	    dense and sparse.
	  </para>

	  <para>
	    A dense vector must meet the interface
	    of <type>std::vector</type>. Its size must be the rank of
	    the free module in which it exists. It is an error, for
	    example, to attempt to perform an arithmetic operation
	    using two dense vectors of different sizes.
	  </para>

	  <programlisting>
#include &lt;vector&gt;

template &lt;class Ring&gt;
void MyAlgorithm (const Ring &amp;R, size_t n)
{
	std::vector&lt;typename Ring::Element&gt; v (n); // A dense vector in R^n

	// Initialise some entries
	R.init (v[0], 1);
	R.init (v[1], -1);
	R.init (v[2], -3);
}</programlisting>

	  <para>
	    The state of the entries of a just declared dense vector
	    is undefined. All entries must be initialised in some
	    fashion before the vector is used. There are several
	    possibilities to do this:
	    <itemizedlist>
	      <listitem>
		<simpara>Initialise the entries directly using
		  array-notation or an iterator, as above;</simpara>
	      </listitem>
	      <listitem>
		<simpara>Copy another vector to the just declared
		  vector;</simpara>
	      </listitem>
	      <listitem>
		<simpara>
		  Scale the vector by zero using the
		  BLAS-function. In this special case the entries of the
		  vector are initialised to zero and need not have been
		  previously initialised. For example:
		</simpara>
	      <programlisting>
Context&lt;Ring&gt; ctx (R);
std::vector&lt;typename Ring::Element&gt; v (n); // A dense vector in R^n

BLAS1::scal (ctx, R.zero (), v);  // Initialise all entries in v to zero</programlisting>
	      </listitem>
	      <listitem>
		<simpara>
		  Initialise the vector from a
		  <type>VectorStream</type>. For example:
		</simpara>
		<programlisting>
RandomDenseStream&lt;Ring, std::vector&lt;typename Ring::Element&gt; &gt; stream (R, n);
std::vector&lt;typename Ring::Element&gt; v (n); // A dense vector in R^n

stream &gt;&gt; v;  // Obtain a random vector in R^n</programlisting>
	      </listitem>
	    </itemizedlist>
	  </para>

	  <para>
	    Alternatively, the type
	    <type>Vector&lt;Ring&gt;::Dense</type> may be used to
	    declare dense vectors. For general rings, this is just an
	    alias for <type>std::vector&lt;typename
	    Ring::Element&gt;</type>.
	  </para>

	  <para>
	    A sparse vector must appear as an STL-vector of
	    index-entry (STL-)pairs,
	    i.e. <type>std::vector&lt;std::pair&lt;unsigned int,
	    typename Ring::Element&gt; &gt;</type>. There are no
	    requirements on its size and the module in which it exists
	    is not defined. Indices must be in strictly increasing
	    order and the zero-element is not allowed as an entry
	    (such an entry should be removed from the vector). Indices
	    which have no corresponding entry in the vector are taken
	    to be zero. Normally such vectors are built progressively
	    using <function>push_back</function>.
	  </para>

	  <para>
	    To declare a sparse vector,
	    use <type>Vector&lt;Ring&gt;::Sparse</type>.
	  </para>

	  <programlisting>
#include &lt;lela/vector/sparse.h&gt;

using namespace LELA;

template &lt;class Ring&gt;
void MyAlgorithm (const Ring &amp;R)
{
	typename Vector&lt;Ring&gt;::Sparse v;

	// Index zero gets value -1
	v.push_back (typename Vector&lt;Ring&gt;::Sparse::value_type (0, Ring::Element ()));
	R.init (v.back ().second, -1);

	// Index 15 gets value 3
	v.push_back (typename Vector&lt;Ring&gt;::Sparse::value_type (15, Ring::Element ()));
	R.init (v.back ().second, 3);

	// Index 23 gets value 10
	v.push_back (typename Vector&lt;Ring&gt;::Sparse::value_type (23, Ring::Element ()));
	R.init (v.back ().second, 10);
}</programlisting>
	</section>
	<section>
	  <title>Representation-types for GF(2)</title>

	  <para>
	    Over GF(2), three types are permitted: dense, sparse, and hybrid.
	  </para>

	  <para>
	    The dense type is in principle similar to that for general
	    rings, but requires additional interfaces to permit
	    parallel computations on words.
	  </para>

	  <programlisting>
#include &lt;lela/ring/gf2.h&gt;

using namespace LELA;

void MyAlgorithm (const GF2 &amp;F, unsigned int n)
{
	Vector&lt;GF2&gt;::Dense v (n);

	*(v.word_begin ()) = 0xf0f0f0f0f0f0f0f0ULL;     // Set all of the first 64 bits of the vector simultaneously
	*(v.word_begin () + 1) = 0xaaaaaaaaaaaaaaaaULL; // Set all of the second 64 bits of the vector simultaneously
	v.back_word () = 0xeeee5555eeee5555ULL;         // Set the final 64 bits of the vector simultaneously
}</programlisting>

	  <para>
	    As with dense vectors over arbitrary rings, the module in
	    which the vector exists is defined by the vector's size.
	  </para>

	  <para>
	    The sparse type, accessed
	    through <type>Vector&lt;GF2&gt;::Sparse</type> is just
	    an <type>std::vector</type> of indices corresponding to
	    nonzero entries. The indices must be in strictly
	    increasing order.
	  </para>

	  <programlisting>
#include &lt;lela/ring/gf2.h&gt;

using namespace LELA;

void MyAlgorithm (const GF2 &amp;F)
{
	Vector&lt;GF2&gt;::Sparse v;

	v.push_back (1);   // Index 1 gets value one
	v.push_back (15);  // Index 15 gets value one
	v.push_back (23);  // Index 23 gets value one
}</programlisting>

	  <para>
	    As with general sparse vectors, nonexistent indices are
	    taken to be zero. The vector need not be of a particular
	    size, and the module in which it exists is not well
	    defined.
	  </para>

	  <para>
	    The hybrid vector is a mixture of sparse and dense
	    representations. As with a sparse vector, it appears as a
	    vector of pairs. The space of indices is divided into
	    blocks each of size equal to the number of bits in a word
	    (normally 64 bits). The first entry of a pair is the index
	    of the <emphasis>block</emphasis> and the second is the
	    word located at that block. Missing indices correspond to
	    the zero word.
	  </para>

	  <para>
	    This representation is well suited to vectors over GF(2)
	    with large blocks of zeros as well as dense blocks. It
	    permits fast parallel operations on vectors but, provided
	    the zero-blocks are large enough, saves memory as compared
	    with the dense representation.
	  </para>

	  <para>
	    To construct a hybrid-vector,
	    use <type>Vector&lt;GF2&gt;::Hybrid</type>. The interface
	    is then similar to that of sparse vectors over general
	    rings.
	  </para>

	  <programlisting>
#include &lt;lela/ring/gf2.h&gt;

using namespace LELA;

void MyAlgorithm (const GF2 &amp;R)
{
	typename Vector&lt;GF2&gt;::Hybrid v;

	// Append entries to the vector
	v.push_back (Vector&lt;GF2&gt;::Hybrid::value_type (0, 0xffff0000ffff0000ULL));  // First 64 indices
	v.push_back (Vector&lt;GF2&gt;::Hybrid::value_type (1, 0xf0f0f0f0f0f0f0f0ULL));  // Second 64 indices
	v.push_back (Vector&lt;GF2&gt;::Hybrid::value_type (5, 0xaaaa5555aaaa5555ULL));  // Indices 5 * 64 - 6 * 64
}</programlisting>
	</section>
      </section>
      <section>
	<title>Types of matrices</title>

	<para>
	  Matrices in LELA are pure containers. They know nothing
	  about the underlying ring or its arithmetic. LELA provides
	  two basic matrix-types: dense and sparse. The interfaces for
	  these matrices are similar.
	</para>

	<para>
	  To declare a dense matrix, use <type>DenseMatrix</type>,
	  which is parametrised by the element-type.
	</para>

	<programlisting>
#include &lt;lela/matrix/dense.h&gt;

using namespace LELA;

template &lt;class Ring&gt;
void MyFunction (const Ring &amp;R)
{
	DenseMatrix&lt;typename Ring::Element&gt; M (5, 5); // Declare a 5x5 matrix

	typename Ring::Element a;
	R.init (a, 5);
	M.setEntry (1, 2, a);  // Set entry (1,2) to a
}</programlisting>

	<para>
	  Note that row- and column-indices start from zero.
	</para>

	<caution>
	  <para>
	    The state of the entries of a newly defined dense matrix is
	    undefined. In particular, all entries should be initialised
	    before the dense matrix is used in any calculation. This can
	    be done:
	  </para>
	  <itemizedlist>
	    <listitem><simpara>with <function>setEntry</function> as above,</simpara></listitem>
	    <listitem><simpara>using the row- or column-iterators as described below,</simpara></listitem>
	    <listitem><simpara>by copying from an existing matrix with the BLAS-interface (see <xref linkend="blas"/>),</simpara></listitem>
	    <listitem><simpara>by scaling the matrix to zero with the BLAS-interface (see <xref linkend="blas"/>),</simpara></listitem>
	    <listitem><simpara>by reading the matrix from a file, or</simpara></listitem>
	    <listitem><simpara>by initialising the matrix with a <type>VectorStream</type> (see reference-documentation).</simpara></listitem>
	  </itemizedlist>
	</caution>

	<para>
	  Dense matrices provide three types of iterators: row,
	  column, and raw. The row- and column-iterators iterate over
	  the row- and column-vectors of the matrix, providing them as
	  dense vectors.
	</para>

	<programlisting>
#include &lt;lela/matrix/dense.h&gt;

using namespace LELA;

template &lt;class Ring&gt;
void MyFunction (const Ring &amp;R)
{
	DenseMatrix&lt;typename Ring::Element&gt; M (5, 5); // Declare a 5x5 matrix

	// Iterate through all the rows, setting the entry 2 on each one to 5 in the ring
	typename DenseMatrix&lt;typename Ring::Element&gt;::RowIterator i;

	for (i = M.rowBegin (); i != M.rowEnd (); ++i)
		R.init ((*i)[2], 5);

	// Iterate through all the columns, setting the entry 1 on each one to 10 in the ring
	typename DenseMatrix&lt;typename Ring::Element&gt;::ColIterator j;

	for (j = M.colBegin (); j != M.colEnd (); ++j)
		R.init ((*i)[1], 10);
}</programlisting>

	<para>
	  The raw iterator iterates through all the entries of the
	  matrix in some order. It is useful for applying an operation
	  uniformly to all entries in the matrix.
	</para>

	<programlisting>
#include &lt;lela/matrix/dense.h&gt;

using namespace LELA;

template &lt;class Ring&gt;
void MyFunction (const Ring &amp;R, DenseMatrix&lt;typename Ring::Element&gt; &amp;M)
{
	// Set all entries in the matrix to 5 in the ring
	DenseMatrix&lt;typename Ring::Element&gt;::RawIterator i;

	for (i = M.rawBegin (); i != M.rawEnd (); ++i)
		R.init (*i, 5);
}</programlisting>

	<para>
	  Each of the iterators has a const equivalent, the name
	  prefixed by <type>Const</type>.
	</para>

	<para>
	  Over GF(2), the declaration of a dense matrix is analogous:
	  use <type>DenseMatrix&lt;bool&gt;</type>. There is however
	  no support for column-iterators.
	</para>

	<note>
	  <para>
	    If LELA is configured with support for M4RI,
	    then <type>DenseMatrix&lt;bool&gt;</type> is a wrapper for
	    the matrix-type in M4RI.
	  </para>
	</note>

	<para>
	  The sparse matrix stores the rows of the matrix as sparse
	  vectors. Its type is <type>SparseMatrix</type> and it is
	  parametrised by element-type.
	</para>

	<programlisting>
#include &lt;lela/matrix/sparse.h&gt;

using namespace LELA;

template &lt;class Ring&gt;
void MyFunction (const Ring &amp;R)
{
	SparseMatrix&lt;typename Ring::Element&gt; M (5, 5); // Declare a 5x5 matrix

	typename Ring::Element a;
	R.init (a, 5);
	M.setEntry (1, 2, a);  // Set entry (1,2) to a
}</programlisting>

	<para>
	  Sparse matrices have no support for column-iterators. Row
	  iterators iterate over row-vectors which are of a sparse
	  type. Otherwise the interface is identical to that
	  of <type>DenseMatrix</type>.
	</para>

	<para>
	  In contrast to dense matrices, a newly defined sparse matrix
	  is by definition the zero-matrix.
	</para>

	<para>
	  Sparse matrices are also parameterised by the type of the
	  row-vector. This can be used to define a sparse matrix over
	  GF(2) whose rows are hybrid vectors.
	</para>

	<programlisting>
#include &lt;lela/ring/gf2.h&gt;
#include &lt;lela/matrix/sparse.h&gt;

using namespace LELA;

void MyFunction (const GF2 &amp;F)
{
	SparseMatrix&lt;bool, Vector&lt;GF2&gt;::Hybrid&gt; M (5, 5); // Declare a 5x5 matrix
	...
}</programlisting>
      </section>
      <section>
	<title>Declaring subvectors, submatrices, and transposed matrices</title>

	<para>
	  LELA provides support for declaring subvectors, submatrices,
	  and transposed matrices which are just windows into their
	  respective containers and therefore require no additional
	  copying. There are, however, some caveats which we will
	  discuss here.
	</para>

	<para>
	  There are two types of subvectors and respectively
	  submatrices: arbitrary and aligned. The starting and
	  possibly ending indices of an aligned subvector or submatrix
	  may be limited to an integral multiple of some
	  value. However, calculations with aligned subvectors and
	  submatrices may be much faster than with arbitrary ones. In
	  addition, the hybrid vector-representation does not permit
	  arbitrary subvectors which can be modified. Aligned
	  subvector and submatrices are useful in recursive algorithms
	  which divide matrices and vectors up and where the decision
	  of where to make the division is open to the implementor of
	  the algorithm. Currently these types are only distinct with
	  vectors over GF(2).
	</para>

	<para>
	  One may declare an arbitrary subvector of a vector of
	  type <type>Vector</type> by defining an object of the
	  type <type>VectorTraits&lt;Ring,
	  Vector&gt;::SubvectorType</type> and passing to its
	  constructor the parent-vector and the starting and ending
	  indices of the subvector. Here we define a
	  subvector <varname>w</varname> of a previously defined
	  vector <varname>v</varname> to span the indices 10 through
	  100 (not including 100 itself).
	</para>

	<programlisting>
Vector v;
...
typename VectorTraits&lt;Ring, Vector&gt;::SubvectorType w (v, 10, 100);</programlisting>

	<para>
	  If the parent-vector is const, then it is required to
	  use <type>VectorTraits&lt;Ring,
	  Vector&gt;::ConstSubvectorType</type> instead.
	</para>

	<programlisting>
const Vector v;
...
typename VectorTraits&lt;Ring, Vector&gt;::ConstSubvectorType w (v, 10, 100);</programlisting>

	<para>
	  To declare an aligned subvector,
	  use <type>VectorTraits&lt;Ring,
	  Vector&gt;::AlignedSubvectorType</type>,
	  respectively <type>VectorTraits&lt;Ring,
	  Vector&gt;::ConstAlignedSubvectorType</type>. In this case
	  the starting index must be an integral multiple of the
	  static integer <type>VectorTraits&lt;Ring,
	  Vector&gt;::align</type>. The ending index should either be
	  an integral multiple of <type>VectorTraits&lt;Ring,
	  Vector&gt;::align</type> or coincide with the end of the
	  vector.
	</para>

	<para>
	  This basic mechanism works for all vector-types but there
	  are a few limitations:
	  <itemizedlist>
	    <listitem><simpara>Mutable (i.e. non-const) subvectors of sparse
	      vectors are not permitted;</simpara></listitem>
	    <listitem><simpara>Arbitrary mutable subvectors of hybrid vectors
	      are not permitted.</simpara></listitem>
	  </itemizedlist>
	</para>

	<caution>
	  <para>
	    It is important to be extremely careful with mutable
	    subvectors of sparse or hybrid vectors. If a subvector is
	    changed, then other subvectors of the same vector will not
	    be updated to reflect that change. For example, suppose you
	    have two subvectors <varname>x_1</varname>
	    and <varname>x_2</varname> of a
	    vector <varname>x</varname>. If you append an entry
	    to <varname>x_1</varname> it will appear correctly
	    in <varname>x</varname>, but <varname>x_2</varname> will be
	    left in an invalid state:
	  </para>

	  <programlisting>
Vector&lt;Ring&gt;::Sparse x;
...
typename Vector&lt;Ring&gt;::Sparse::SubvectorType x_1 (x, 0, 10);
typename Vector&lt;Ring&gt;::Sparse::SubvectorType x_2 (x, 10, 20);
x_1.push_back (5, typename Ring::Element ());
// x_2 now invalid</programlisting>

	  <para>
	    Failure to take this into account may lead to random
	    memory-corruption.
	  </para>

	  <para>
	    This can also be a problem when using the
	    arithmetic-routines described below. It is advised to
	    avoid using two subvectors of a given sparse vector as
	    inputs to the same operation if one of them will be
	    changed, for example:
	  </para>

	  <programlisting>
BLAS2::gemv (ctx, a, A, x_2, b, x_1);  // DANGER: Using both x_1 and x_2!</programlisting>
	</caution>

	<para>
	  Declaring a submatrix is similar. To create an arbitrary
	  mutable submatrix of a given matrix of
	  type <type>Matrix</type>,
	  use <type>Matrix::SubmatrixType</type> and supply to the
	  constructor the containing matrix, the row- and
	  column-indices of the upper left entry (indexed from 0, as
	  usual), and the row- and column-dimensions. The following
	  creates a 5x5 submatrix starting at index (2,2) of a 10x10
	  matrix.
	</para>

	<programlisting>
Matrix M (10, 10);  // M has size 10x10

typename Matrix::SubmatrixType S (M, 2, 2, 5, 5);</programlisting>

	<para>
	  Note the difference with subvectors: for submatrices one
	  supplies the <emphasis>dimensions</emphasis> of the
	  submatrix, while for subvectors one supplies instead
	  the <emphasis>ending index</emphasis>.
	</para>

	<para>
	  If the matrix is const, then
	  use <type>Matrix::ConstSubmatrixType</type>.
	</para>

	<programlisting>
const Matrix M (10, 10);  // M has size 10x10

typename Matrix::ConstSubmatrixType S (M, 2, 2, 5, 5);</programlisting>

	<para>
	  One can create aligned submatrices
	  with <type>Matrix::AlignedSubmatrixType</type>
	  and <type>Matrix::ConstAlignedSubmatrixType</type>. In this
	  case the starting row- and column-indices must be integer
	  multiples of <type>Matrix::rowAlign</type> and respectively
	  <type>Matrix::colAlign</type>. The dimensions should be such
	  that either the ending row and column are aligned with an
	  integer multiple of the above values or they coincide with
	  the end of the matrix.
	</para>

	<para>
	  As with subvectors, it is not permitted to take an mutable
	  arbitrary submatrix of a sparse matrix whose rows or columns
	  are hybrid vectors. Unlike subvectors it is okay to
	  construct a mutable submatrix of a mutable submatrix of a
	  sparse matrix.
	</para>

	<para>
	  To construct a transposed matrix, use the
	  class <type>TransposeMatrix</type>, defined
	  in <filename>lela/matrix/transpose.h</filename>. This class
	  is parametrised by matrix-type.
	</para>

	<programlisting>
#include "lela/matrix/transpose.h"
...
Matrix M;

TransposeMatrix&lt;Matrix&gt; MT (M);</programlisting>

	<para>
	  If the matrix is const, then <type>TransposeMatrix</type>
	  should also be instantiated with the const variant.
	</para>

	<programlisting>
const Matrix M;

TransposeMatrix&lt;const Matrix&gt; MT (M);</programlisting>

	<note>
	  <para>
	    In LELA there also exist
	    classes <type>Subvector</type>, <type>SparseSubvector</type>,
	    and <type>Submatrix</type>. These are basically for internal
	    use. Do not use them unless you are creating your own
	    vector- or matrix-type and wish to employ them to define the
	    subvector or submatrix-types used above.
	  </para>
	</note>
      </section>
    </section>
    <section id="blas">
      <title>Vector- and matrix-arithmetic</title>

      <para>
	Basic vector- and matrix-arithmetic follow the interface of
	BLAS.
      </para>

      <para>
	To use these features, first construct a <emphasis>context
	object</emphasis>. This object encapsulates the ring over
	which computations take place, the configuration of algorithms
	for arithmetic, and temporary storage.
      </para>

      <programlisting>
#include &lt;lela/blas/context.h&gt;

using namespace LELA;

template &lt;class Ring&gt;
void MyFunction (const Ring &amp;R)
{
	Context&lt;Ring&gt; ctx (R);
	...
}</programlisting>

      <caution>
	<para>
	  Context objects are not intended to be reentrant, since they
	  contain temporary storage. If your program is multithreaded,
	  it is necessary to construct one context object per
	  thread. Context objects can be copy-constructed.
	</para>
      </caution>

      <para>
	BLAS-routines are split into three levels: level 1 for
	vector-vector operations, level 2 for matrix-vector
	operations, and level 3 for matrix-matrix operations.. The
	routines in LELA are divided correspondingly into the
	namespaces <type>BLAS1</type>, <type>BLAS2</type>,
	and <type>BLAS3</type>.
      </para>

      <para>
	Use use BLAS-routines at a given level, include the
	header-file <filename>lela/blas/level&lt;l&gt;.h</filename>,
	where &lt;l&gt; is respectively 1, 2, or 3. Then declare the
	context-object and simply invoke the function. The arguments
	generally follow the BLAS-standard.
      </para>

      <para>
	Here is an example with vectors:
      </para>

      <programlisting>
#include &lt;lela/blas/context.h&gt;
#include &lt;lela/blas/level1.h&gt;

using namespace LELA;

template &lt;class Ring, class Vector1, class Vector2&gt;
void MyFunction (const Ring &amp;R, Vector1 &amp;v, Vector2 &amp;w)
{
	Context&lt;Ring&gt; ctx (R);

	BLAS1::axpy (ctx, R.one (), v, w); // Replace w by v + w
	BLAS1::scal (ctx, R.minusOne (), v); // Replace v by -v

	typename Ring::Element a;

	BLAS1::dot (ctx, a, v, w);  // Compute the dot-product of v and w and store it in a
}</programlisting>

      <para>
	And another example with level 2 operations:
      </para>

      <programlisting>
#include &lt;lela/blas/context.h&gt;
#include &lt;lela/blas/level2.h&gt;

using namespace LELA;

template &lt;class Ring, class Vector, class Matrix&gt;
void MyFunction (const Ring &amp;R, Vector &amp;v, Vector &amp;w, Matrix &amp;A)
{
	Context&lt;Ring&gt; ctx (R);

	BLAS2::ger (ctx, R.one (), v, w, A); // Replace A by v w^T + A
	BLAS2::gemv (ctx, R.one (), A, v, R.minusOne (), w); // Replace w by A v - w

	// Replace v by U^-1 v, where U is the upper triangular part of A with ones on the diagonal
	BLAS2::trsv (ctx, A, v, UpperTriangular, true);
}</programlisting>

      <para>
	Because matrix- and vector-types in LELA are distinct, several
	level 1 operations have in level 3 matrix-equivalents which
	are not present in the BLAS standard. These
	include <function>copy</function>, <function>scal</function>,
	and <function>axpy</function>.
      </para>

      <programlisting>
#include &lt;lela/blas/context.h&gt;
#include &lt;lela/blas/level3.h&gt;

using namespace LELA;

template &lt;class Ring, class Matrix1, class Matrix2, class Matrix3&gt;
void MyFunction (const Ring &amp;R, Matrix1 &amp;A, Matrix2 &amp;B, Matrix3 &amp;C)
{
	Context&lt;Ring&gt; ctx (R);

	BLAS3::axpy (ctx, R.one (), A, B); // Replace B by A + B
	BLAS3::scal (ctx, R.minusOne (), A); // Replace A by -A

	BLAS3::gemm (ctx, R.one (), A, B, R.one (), C);  // Replace C by A * B + C
}</programlisting>

      <para>
	There are some limitations in the combinations of types which
	can be used in some interfaces. See the
	reference-documentation for more details.
      </para>

      <para>
	In addition to basic BLAS-functionality there is support for
	applying permutations to both vectors and matrices as well as
	input and output of vectors and matrices.
      </para>

      <note>
	<para>
	  Support for symmetric, skew-symmetric, and banded matrices has
	  not been implemented.
	</para>
      </note>

      <para>
	While LELA strives to be as flexible as possible with respect
	to the inputs to the BLAS-routines, there are some
	combinations whose support is essentially impossible (or at
	least far to difficult to implement). They must therefore be
	avoided. Examples include:
      </para>

      <itemizedlist>
	<listitem>
	  <simpara><function>BLAS3::axpy</function> (i.e. aX + Y -&gt;
	    Y, X and Y matrices) where X and Y not support an
	    interator-type in common, e.g. if X is a sparse matrix and Y
	    is the transpose of a sparse matrix;</simpara>
	</listitem>
	<listitem>
	  <simpara><function>BLAS3::gemm</function> (i.e. aAB + bC
	  -&gt; C, A, B, and C matrices) where A and B are both sparse
	  matrices and C is the transpose of a sparse matrix, or where
	  A and B are both transposed sparse matrices and C is an
	  ordinary sparse matrix;</simpara>
	</listitem>
	<listitem>
	  <simpara><function>BLAS2::trmv</function>
	  and <function>BLAS2::trsv</function> (i.e. Tx -&gt; x,
	  T<superscript>-1</superscript>x -&gt; x, T a triangular
	  matrix, x a vector) where x is a sparse or hybrid
	  vector;</simpara>
	</listitem>
	<listitem>
	  <simpara><function>BLAS2::trmm</function>
	  and <function>BLAS2::trsm</function> (i.e. TB -&gt; B,
	  T<superscript>-1</superscript>B -&gt; B, T a triangular
	  matrix, B a matrix) where B is a transposed sparse or hybrid
	  matrix.</simpara>
	</listitem>
      </itemizedlist>

      <para>
	Please consult the reference-documentation for a more detailed
	account.
      </para>
    </section>
    <section>
      <title>Using higher level solutions</title>

      <para>
	Higher level functionality, such as computing the row echelon
	form of a matrix, is provided
	by <emphasis>solutions</emphasis>. Each solution is
	encapsulated in a class.
      </para>

      <section>
	<title>Computing the row-echelon form</title>

	<para>
	  To compute the row echelon form of a matrix, use the
	  solution <type>EchelonForm</type>. Its header-file
	  is <filename>lela/solutions/echelon-form.h</filename>.
	</para>

	<para>
	  The use is quite straightforward:
	</para>

	<programlisting>
#include &lt;lela/solutions/echelon-form.h&gt;

using namespace LELA;

template &lt;class Ring, class Matrix&gt;
void ComputeRowEchelonForm (const Ring &amp;R, Matrix &amp;A)
{
	Context&lt;Ring&gt; ctx (R);
	EchelonForm&lt;Ring&gt; EF (ctx);

	echelonize (A); // A now replaced by its row echelon form
}</programlisting>

	<para>
	  There is also support for computing the reduced row echelon
	  form of a matrix:
	</para>

	<programlisting>
#include &lt;lela/solutions/echelon-form.h&gt;

using namespace LELA;

template &lt;class Ring, class Matrix&gt;
void ComputeRowEchelonForm (const Ring &amp;R, Matrix &amp;A)
{
	Context&lt;Ring&gt; ctx (R);
	EchelonForm&lt;Ring&gt; EF (ctx);

	echelonize (A, true); // A now replaced by its reduced row echelon form
}</programlisting>

	<para>
	  You can also instruct <type>EchelonForm</type> to use a
	  particular method when computing the row-echelon form. For
	  example, if your matrix comes from the F4 algorithm, it is
	  useful to use the method of Faugère-Lachartre:
	</para>

	<programlisting>
#include &lt;lela/solutions/echelon-form.h&gt;

using namespace LELA;

template &lt;class Ring, class Matrix&gt;
void ComputeRowEchelonForm (const Ring &amp;R, Matrix &amp;A)
{
	Context&lt;Ring&gt; ctx (R);
	EchelonForm&lt;Ring&gt; EF (ctx);

	echelonize (A, true, METHOD_FAUGERE_LACHARTRE); // A now replaced by its reduced row echelon form
}</programlisting>

	<para>
	  The supported methods are as follows:
	</para>

	<itemizedlist>
	  <listitem>
	    <para><literal>METHOD_STANDARD_GJ</literal>, naive
	    Gaussian elimination. Slow, but available for any type of
	    matrix in with any configuration.</para>
	  </listitem>
	  <listitem>
	    <para><literal>METHOD_ASYMPTOTICALLY_FAST_GJ</literal>,
	    asymptotically fast Gaussian elimination (using possibly
	    fast matrix-multiplication). Only available for dense
	    matrices.</para>
	  </listitem>
	  <listitem>
	    <para><literal>METHOD_M4RI</literal>, wrapper for the
	    method in M4RI. Only available for dense matrices over
	    GF(2) when M4RI is enabled.</para>
	  </listitem>
	  <listitem>
	    <para><literal>METHOD_FAUGERE_LACHARTRE</literal>, method
	    based on the algorithm of Faugère and Lachartre. Only
	    available for matrices of the form coming from the F4
	    algorithm.</para>
	  </listitem>
	</itemizedlist>
      </section>
    </section>
    <section>
      <title>Input and output of matrices and vectors</title>

      <para>
	Input and output are provided within the BLAS-interface.
      </para>

      <para>
	The interfaces for inputing respectively outputing vectors
	are <function>BLAS1::read</function>
	respectively <function>BLAS1::write</function>. They accept as
	arguments the C++ stream and the vector in question.
      </para>

      <programlisting>
#include &lt;iostream&gt;
#include &lt;lela/blas/level1.h&gt;

using namespace LELA;

template &lt;class Ring, class Vector&gt;
void ReadAndWriteVector (const Ring &amp;R, Vector &amp;v)
{
	Context&lt;Ring&gt; ctx (R);

	std::cout &lt;&lt; "Enter a vector: ";
	BLAS1::read (ctx, std::cin, v);

	std::cout &lt;&lt; "You entered: ";
	BLAS1::write (ctx, std::cout, v) &lt;&lt; std::endl;
}</programlisting>

      <para>
	The input-format should be a list of numbers which can be
	interpreted by <function>Ring::read</function>. The
	output-format is a comma-separated list of entries in square
	brackets.
      </para>

      <para>
	Input and output of matrices is provided by similar interfaces
	in <type>BLAS3</type>. The parameters are the same with the
	addition of a parameter <parameter>format</parameter> which
	specifies the format for the matrix.
      </para>

      <programlisting>
#include &lt;iostream&gt;
#include &lt;lela/blas/level3.h&gt;

using namespace LELA;

template &lt;class Ring, class Matrix&gt;
void ReadAndWriteVector (const Ring &amp;R, Matrix &amp;A, std::istream &amp;is)
{
	Context&lt;Ring&gt; ctx (R);

	std::cout &lt;&lt; "Reading matrix...";
	BLAS3::read (ctx, istream, A, FORMAT_DETECT);

	std::cout &lt;&lt; "Matrix: " &lt;&lt; std::endl;
	BLAS3::write (ctx, std::cout, A, FORMAT_PRETTY);
}</programlisting>

      <para>
	Some examples of formats are:
      </para>

      <itemizedlist>
	<listitem>
	  <simpara><literal>FORMAT_PRETTY</literal>, suitable for output to
	    the console or a text-file so that the matrix can be examined
	    by the user</simpara>
	</listitem>
	<listitem>
	  <simpara><literal>FORMAT_DUMAS</literal>, suitable for the
	    storage of sparse matrices</simpara>
	</listitem>
	<listitem>
	  <simpara><literal>FORMAT_MAPLE</literal>, for interacting with
	    Maple</simpara>
	</listitem>
	<listitem>
	  <simpara><literal>FORMAT_MATLAB</literal>, for interacting with
	    Matlab</simpara>
	</listitem>
	<listitem>
	  <simpara><literal>FORMAT_SAGE</literal>, for interacting with
	    Sage</simpara>
	</listitem>
	<listitem>
	  <simpara><literal>FORMAT_PNG</literal>, good for large matrices
	    over GF(2). Only available for matrices over GF(2) and only if
	    LELA is configured with support for libpng.</simpara>
	</listitem>
	<listitem>
	  <simpara><literal>FORMAT_DETECT</literal>, try to detect the
	    format of a matrix. Only makes sense
	    for <function>read</function>.</simpara>
	</listitem>
      </itemizedlist>

      <para>
	The format <literal>FORMAT_PRETTY</literal> replaces zero
	entries with a period to make nonzero entries more visible. It
	also attempts to align entries by column so that the matrix
	appears correctly in a fixed width typeface.
      </para>
    </section>
    <section>
      <title>The commentator and debugging-support</title>
      <section>
	<title>Enabling and disabling precondition-checks</title>

	<para>
	  Throughout LELA there are checks of the form
	  <programlisting>
lela_check (condition);</programlisting>
	  These check that the input to algorithms meets the required
	  preconditions. These checks are disabled by default, but can
	  be enabled by defining the macro <constant>DEBUG</constant>
	  when compiling both the library and sources.
	</para>

      </section>
      <section>
	<title>Using and configuring the commentator</title>

	<para>
	  LELA has a facility called
	  the <emphasis>commentator</emphasis> for reporting
	  information about computations it performs. This is
	  particularly useful for obtaining benchmarks.
	</para>

	<para>
	  A program-run is divided conceptually
	  into <emphasis>activities</emphasis> which form a tree. To
	  mark the beginning and end of an activity, use the
	  interfaces <function>commentator.start</function> and
	  respectively <function>commentator.stop</function>.
	</para>

	<programlisting>
#include &lt;lela/util/commentator.h&gt;

using namespace LELA;

void MyFunction ()
{
	commentator.start ("Description of activity", __FUNCTION__);
	...
	commentator.stop (MSG_DONE);
}</programlisting>

	<para>
	  The second argument
	  to <function>commentator.start</function> should be the name
	  of the calling function. The argument
	  to <function>commentator.stop</function> is a short string
	  indicating the state at the end of the activity, such as
	  whether a test passed. The
	  macros <literal>MSG_DONE</literal>
	  and <literal>MSG_STATUS</literal> provide standardised
	  strings for this purpose.
	</para>

	<para>
	  One can use the commentator to report information about a
	  computation with the
	  interface <function>commentator.report</function>, which
	  returns an <type>std::ostream</type>.
	</para>

	<programlisting>
#include &lt;lela/util/commentator.h&gt;

using namespace LELA;

void MyFunction ()
{
	commentator.start ("Description of activity", __FUNCTION__);

	std::ostream &amp;report = commentator.report (Commentator::LEVEL_IMPORTANT, INTERNAL_DESCRIPTION);

	report &lt;&lt; "Some information about the computation." &lt;&lt; std::endl;

	commentator.stop (MSG_DONE);
}</programlisting>

	<para>
	  The first parameter
	  to <function>commentator.report</function> indicates the
	  importance of the information; it can be
	  either <constant>Commentator::LEVEL_IMPORTANT</constant>, <constant>Commentator::LEVEL_NORMAL</constant>,
	  or <constant>Commentator::LEVEL_UNIMPORTANT</constant>. The
	  second parameter indicates the general category of the
	  information. Possible values
	  include <constant>INTERNAL_DESCRIPTION</constant>, <constant>INTERNAL_WARNING</constant>, <constant>INTERNAL_ERROR</constant>, <constant>TIMING_MEASURE</constant>,
	  and <constant>PROGRESS_REPORT</constant>.
	</para>

	<para>
	  The commentator includes a sophisticated system to select
	  which messages are printed and which are not. Messages to be
	  printed can be selected according to the nesting-depth of
	  the activity, the importance-level, and the
	  classification. See the commentator's documentation for more
	  information.
	</para>

	<para>
	  The commentator can produce both a brief output for the
	  console and a more detailed output which can be directed to
	  a file. See the commentator's documentation for more
	  information.
	</para>
      </section>
      <section>
	<title>Disabling the commentator entirely</title>

	<para>
	  To disable the commentator entirely, define the
	  macro <constant>DISABLE_COMMENTATOR</constant>. Then all
	  commentator-lines compile to nothing.
	</para>
      </section>
    </section>
    <section>
      <title>Dealing with compiler-errors</title>

      <para>
	Since LELA is a template-library, it is possible to encounter
	difficult compiler-errors when compiling against it. In
	particular, some errors appear only when a particular class or
	function is instantiated. The resulting output can be quite
	difficult to understand. Here we give some tips to help to
	solve such problems.
      </para>

      <itemizedlist>
	<listitem>
	  <simpara>
	    Check carefully that the template-arguments are of the
	    correct type and in the correct order. Since there is no
	    direct type-checking of template-arguments in C++, using the
	    wrong types will result in unpredictable errors during
	    instantiation.
	  </simpara>
	</listitem>
	<listitem>
	  <simpara>
	    If using submatrices or subvectors, check that you have
	    properly declared subobjects of const objects using the
	    corresponding const type. For example:
	  </simpara>
	  <programlisting>
const Matrix M;

typename Matrix::SubmatrixType N (M, 2, 2, 5, 5);       // ERROR!
typename Matrix::ConstSubmatrixType N (M, 2, 2, 5, 5);  // Correct</programlisting>
	</listitem>
	<listitem>
	  <simpara>
	    Check that you are not using a forbidden combination of
	    types for BLAS-routines (see section on matrix- and
	    vector-arithmetic above). This type of error will usually
	    manifest itself when compiling as "No matching function for
	    call to &lt;function&gt;_impl", where &lt;function&gt; is
	    the name of the offending BLAS-routine.
	  </simpara>
	</listitem>
	<listitem>
	  <simpara>
	    Many errors of the form "No matching function for call
	    to..." or "No matching constructor..." result from attempts
	    to remove a <type>const</type> from a type. For example, the
	    following code will result in an error:
	  </simpara>
	  <programlisting>
void MyFunction (const Matrix &amp;M)
{
	typename Matrix::RowIterator i = M.rowBegin ();  // ERROR!
}</programlisting>
	  <simpara>
	    In this case, because <varname>M</varname>
	    is <type>const</type>, one must
	    use <type>ConstRowIterator</type> instead:
	  </simpara>
	  <programlisting>
void MyFunction (const Matrix &amp;M)
{
	typename Matrix::ConstRowIterator i = M.rowBegin ();  // Correct
}</programlisting>
	</listitem>
	<listitem>
	  <simpara>
	    Consider using the compiler Clang (see
	    <ulink url="http://clang.llvm.org/">their website</ulink>)
	    rather than GCC. Its error-output is much more readable. To
	    use Clang rather than GCC, use
	  </simpara>
	  <programlisting>
CXX=clang ./configure</programlisting>
	  <simpara>
	    when configuring LELA.
	  </simpara>
	</listitem>
	<listitem>
	  <simpara>
	    If you are really stuck, send an email to the mailing list
	    at lela-users@googlegroups.com.
	  </simpara>
	</listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Extending the library</title>

    <para>
      LELA is designed to be flexible and generic so that one can
      provide one's own types of rings, vectors, and matrices, as well
      as one's own matrix- and vector-arithmetic, and they will be
      properly integrated into the library.
    </para>

    <section>
      <title>Creating new rings</title>

      <para>
	There are three ways to create rings:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    One can simply define a class meeting the proper
	    interface and then instantiates the remaining parts of the
	    library on that class. When the element-type and
	    arithmetic-operations are simple (such as
	    with <type>Modular</type>), this will typically provide the
	    best performance by avoiding function-calls and enabling
	    more compiler-optimisations. It comes however at the cost of
	    more code-bloat, since practically the entire library must
	    be instantiated for that ring-type.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    One can define a class inheriting
	    from <type>RingInterface</type>, which is parametrised by
	    element-type. Then one instantiates all remaining classes
	    and functions on <type>RingInterface&lt;Element&gt;</type>,
	    where <type>Element</type> is one's chosen
	    element-type. This avoids multiple instantiations in the
	    case that one uses the library with multiple rings using the
	    same element-type, but is slower than the method above
	    because it relies on the invocation of virtual
	    methods.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    One can define a class inheriting
	    from <type>RingInterface&lt;AbstractElement&gt;</type>. The
	    type <type>AbstractElement</type> allows in principle any
	    element-type to be represented. Thus the entire library is
	    only instantiated once, even when multiple rings with
	    multiple element-types are used. It comes at a cost of both
	    performance and memory-overhead.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	To implement a ring with the first method, it is necessary to
	create a class which exports the same interface
	as <type>RingInterface</type>, implementing ring-arithmetic
	I/O, and initialisation of ring-elements. One can
	use <type>RingInterface</type> as a starting-point. One must
	define an element-type; any C++ type, builtin or otherwise,
	may serve as one.
      </para>

      <programlisting>
class MyRing
{
public:
	typedef int Element;

	Element &amp;add (Element &amp;a, const Element &amp;b, const Element &amp;c)
		{ a = b + c; return a; }       // Implementation
	...
};</programlisting>

      <para>
	See <xref linkend="newblas"/> for more details on this mechanism.
      </para>

      <para>
	To use the second method, create a class which derives
	from <type>RingInterface&lt;Element&gt;</type>,
	where <type>Element</type> is the C++-type you have chosen to
	represent elements. The class <type>RingInterface</type> is an
	abstract base-class implementing the required
	ring-interface. It is necessary to override all pure virtual
	methods in it.
      </para>

      <programlisting>
class MyRing : public RingInterface&lt;MyElement&gt;
{
public:
	typedef MyElement Element;

	Element &amp;add (Element &amp;a, const Element &amp;b, const Element &amp;c)
	{
		a = b + c;
		return a;
	}
	...
};</programlisting>

      <para>
	To use the third method, define a class which inherits
	from <type>RingInterface&lt;AbstractElement&gt;</type>. The
	element-type is then <type>AbstractElement</type>. This type
	contains two members:
	<itemizedlist>
	  <listitem><simpara><varname>ref</varname>, an void pointer to element-data, the content of which you are free to define,</simpara></listitem>
	  <listitem><simpara><varname>ring</varname>, a pointer to the ring.</simpara></listitem>
	</itemizedlist>
	Any method in your ring-class which initialises a ring-element
	(that is <function>init</function>, <function>copy</function>,
	<function>read</function>, and all out-of-place arithmetic
	operations) must initialise <emphasis>both</emphasis>
	<varname>ref</varname> and <varname>ring</varname>.
      </para>

      <para>
	The class <type>RingInterface</type> implements the virtual
	methods <function>ref</function> and
	<function>unref</function>, which are called in the
	copy-constructor and assignment-operator and in the destructor
	of <type>ElementAbstract</type>, respectively (provided
	<varname>ring</varname> is properly initialised).
      </para>

      <para>
	This mechanism allows a simple memory-model based on
	reference-counting. For example:
      </para>

      <programlisting>
class MyRing
{
public:
	typedef AbstractElement Element;

	void ref (Element &amp;x)
		{ if (x.ref != NULL) ++static_cast&lt;MyElement *&gt; (x.ref).refcount; }

	void unref (Element &amp;x)
	{
		if (x.ref != NULL) {
			--static_cast&lt;MyElement *&gt; (x.ref).refcount;
			if (static_cast&lt;MyElement *&gt; (x.ref).refcount == 0)
				delete static_cast&lt;MyElement *&gt; (x.ref);
		}
	}

	Element &amp;add (Element &amp;a, const Element &amp;b, const Element &amp;c)
	{
		a.ring = this;
		unref (a);
		static_cast&lt;MyElement *&gt; (a.ref) = new MyElement;  // Assume MyElement::refcount initialised to 1
		*static_cast&lt;MyElement *&gt; (a.ref) = *static_cast&lt;MyElement *&gt; (b) + *static_cast&lt;MyElement *&gt; (c);
		return a;
	}
	...
};</programlisting>

      <para>
	It is advantageous to define a stack of BLAS-operations for
	the new ring. Otherwise the generic fallback operations will
	be used in all cases, reducing performance substantially. See
	the section <xref linkend="newblas"/> for more information on
	this mechanism.
      </para>

      <para>
	In any event, the header-files defining the BLAS-modules for
	your new ring must be included at the end of the header-file
	defining your ring. In particular, the
	files <filename>lela/blas/level1-generic.h</filename>, <filename>lela/blas/level2-generic.h</filename>,
	and <filename>lela/blas/level3-generic.h</filename> must be
	included.
      </para>
    </section>
    <section>
      <title>Creating new vector- and matrix-types</title>

      <para>
	Creating new types of vectors and matrices is a matter of
	creating a class which meets the proper interface. LELA
	provides example-files which can be used as a starting-point
	and which have documentation for the required members.
      </para>

      <itemizedlist>
	<listitem><simpara>For matrices, see <filename>lela/matrix/interface.h</filename></simpara></listitem>
	<listitem><simpara>For dense vectors, see <filename>lela/vector/dense-interface.h</filename></simpara></listitem>
	<listitem><simpara>For sparse vectors, see <filename>lela/vector/sparse-interface.h</filename></simpara></listitem>
	<listitem><simpara>For dense 0-1 vectors, see <filename>lela/vector/dense01-interface.h</filename></simpara></listitem>
	<listitem><simpara>For sparse 0-1 vectors, see <filename>lela/vector/sparse01-interface.h</filename></simpara></listitem>
	<listitem><simpara>For hybrid 0-1 vectors, see <filename>lela/vector/hybrid01-interface.h</filename></simpara></listitem>
      </itemizedlist>
    </section>
    <section id="newblas">
      <title>Extending the BLAS-implementations</title>

      <para>
	LELA provides a flexible mechanism for extending its vector-
	and matrix-arithmetic system to support new algorithms and to
	provide wrappers for specialised libraries. Here we explain a
	bit how this system works then how to extend it.
      </para>

      <para>
	The BLAS-subsystem is divided into
	<emphasis>Modules</emphasis> which exist in a hierarchy. Each
	module takes responsibility for some calculations and passes
	those which it cannot handle to the next module down in
	hierarchy. At the bottom is <type>GenericModule</type> which
	acts as a catch-all for calculations which cannot be performed
	elsewhere. It should take any reasonable combination of input
	and produce the correct output, possibly with limited
	performance.
      </para>

      <para>
	At the top is <type>AllModules</type>, a type parametrised on
	the ring whose specialisation to a given ring should provide
	all available functionality over that ring given the library's
	configuration. This type merely specifies in a generic way
	what the highest level of the hierachy is; it provides no
	functionality of its own.
      </para>

      <para>
	An example of a hierarchy is that for computations over GF2 in
	the case that M4RI is installed. We have the following:
      </para>

      <itemizedlist>
	<listitem><simpara><type>AllModules&lt;GF2&gt;</type></simpara></listitem>
	<listitem><simpara><type>M4RIModules</type>, which acts as a wrapper for M4RI</simpara></listitem>
	<listitem><simpara><type>GenericModule</type>, which provides the remaining functionality not provided by M4RI</simpara></listitem>
      </itemizedlist>

      <para>
	Each BLAS-routine has a associated class which has the same
	name as the routine with a preceeding underscore. The class is
	parametrised by the Ring and by the
	<emphasis>module-tag</emphasis>, which is an memberless
	structure whose type is obtained from a Module with
	<literal>typename Module::Tag</literal>. This allows the class
	to be specialised for both the ring-type and the module of
	computation.
      </para>

      <para>
	Each class should in turn contain a single static public
	method <function>op</function> which implements the required
	functionality. It may invoke a specialised function based on
	the representation-type of the vector-input, the iterator-type
	of the matrix-input, and other things. It must be parametrised
	by Modules (the computational module-object itself) as well as
	any vector- or matrix-types which appear in the input.
      </para>

      <para>
	As an example, we provide here the class for
	<function>gemm</function>.
      </para>

      <programlisting>
template &lt;class Ring, class ModulesTag&gt;
class _gemm
{
public:
	template &lt;class Modules, class Matrix1, class Matrix2, class Matrix3&gt;
	static Matrix3 &amp;op (const Ring &amp;F, Modules &amp;M, const typename Ring::Element &amp;a, const Matrix1 &amp;A, const Matrix2 &amp;B, const typename Ring::Element &amp;b, Matrix3 &amp;C)
		{ return _gemm&lt;Ring, typename ModulesTag::Parent&gt;::op (F, M, a, A, B, b, C); }
};</programlisting>

      <para>
	This is the default implementation which passes the
	calculation onto the next module-type, whose tag is given by
	<type>ModulesTag::Parent</type>. Eventually the generic module
	is reached which will handle the calculation.
      </para>

      <para>
	To create a new module it is therefore necessary to create

	<itemizedlist>
	  <listitem><simpara>a <type>Module</type> structure,</simpara></listitem>
	  <listitem><simpara>a specialisation of the implementation-class for each function being implemented in that module</simpara></listitem>
	</itemizedlist>
      </para>

      <para>
	Here is an example of a Module-structure:
      </para>

      <programlisting>
template &lt;class Element&gt;
struct ZpModule&lt;integer&gt; : public GenericModule&lt;Modular&lt;integer&gt; &gt;
{
	struct Tag { typedef typename GenericModule&lt;Modular&lt;Element&gt; &gt;::Tag Parent; };

	/// Number of times a product of two elements can be added before it is necessary to reduce by the modulus; 0 for unlimited
	size_t block_size;

	mutable std::vector&lt;typename ModularTraits&lt;Element&gt;::DoubleFatElement&gt; _tmp;

	ZpModule (const Modular&lt;Element&gt; &amp;R) : block_size (((typename ModularTraits&lt;Element&gt;::DoubleFatElement) -1LL) / ((R._modulus - 1) * (R._modulus - 1))) {}
};</programlisting>

      <para>
	The structure should inherit from its parent-module, in this
	case <type>GenericModule</type>.
      </para>

      <para>
	The first member is the <type>Tag</type>, which contains a
	single typedef giving the parent-module's tag. Note that both
	this typedef and inheritance of the parent-module are
	required.
      </para>

      <para>
	The Module-structure may contain parameters to configure the
	computation, such as <varname>block_size</varname> above, as
	well as temporary storage, such as <varname>_tmp</varname>
	above.
      </para>

      <para>
	A module must contain a constructor which takes a ring. This
	allows for example <varname>block_size</varname> to be
	configured based on the ring. So that modules may be
	constructed generically, every module must have such a
	constructor.
      </para>

      <para>
	Once the module is defined, the implementation-classes for
	functionality which the module implements should be
	specialised to the module's tag and, if necessary, to the ring
	over which the module operates. As an example, we show the
	definition of the dot-product with <type>ZpModule</type>:
      </para>

      <programlisting>
template &lt;&gt;
class _dot&lt;Modular&lt;uint8&gt;, ZpModule&lt;uint8&gt;::Tag&gt;
{
	template &lt;class reference, class Vector1, class Vector2&gt;
	static reference &amp;dot_impl (const Modular&lt;uint8&gt; &amp;F, ZpModule&lt;uint8&gt; &amp;M, reference &amp;res, const Vector1 &amp;x, const Vector2 &amp;y,
				    VectorRepresentationTypes::Dense, VectorRepresentationTypes::Dense);

	template &lt;class reference, class Vector1, class Vector2&gt;
	static reference &amp;dot_impl (const Modular&lt;uint8&gt; &amp;F, ZpModule&lt;uint8&gt; &amp;M, reference &amp;res, const Vector1 &amp;x, const Vector2 &amp;y,
				    VectorRepresentationTypes::Sparse, VectorRepresentationTypes::Dense);

	template &lt;class reference, class Vector1, class Vector2&gt;
	static reference &amp;dot_impl (const Modular&lt;uint8&gt; &amp;F, ZpModule&lt;uint8&gt; &amp;M, reference &amp;res, const Vector1 &amp;x, const Vector2 &amp;y,
				    VectorRepresentationTypes::Dense, VectorRepresentationTypes::Sparse)
		{ return op (F, M, res, y, x); }

	template &lt;class reference, class Vector1, class Vector2&gt;
	static reference &amp;dot_impl (const Modular&lt;uint8&gt; &amp;F, ZpModule&lt;uint8&gt; &amp;M, reference &amp;res, const Vector1 &amp;x, const Vector2 &amp;y,
				    VectorRepresentationTypes::Sparse, VectorRepresentationTypes::Sparse);

public:
	template &lt;class Modules, class reference, class Vector1, class Vector2&gt;
	static reference &amp;op (const Modular&lt;uint8&gt; &amp;F, Modules &amp;M, reference &amp;res, const Vector1 &amp;x, const Vector2 &amp;y)
		{ return dot_impl (F, M, res, x, y,
				   typename VectorTraits&lt;Modular&lt;uint8&gt;, Vector1&gt;::RepresentationType (),
				   typename VectorTraits&lt;Modular&lt;uint8&gt;, Vector2&gt;::RepresentationType ()); }
};</programlisting>

      <para>
	In this case the dot-product is specialised on the
	representation-types of the input-vectors.
      </para>

      <para>
	When defining a new ring, it is important to define a
	module-hierarchy for it. Otherwise the generic module is used
	for all calculations and this may be quite slow. To do this,
	simply specialise <type>AllModules</type> to the ring-type and
	define the next module in the hierachy. Some modules, such as
	<type>StrassenModule</type> providing fast
	matrix-multiplication, are in turn parametrised by
	<emphasis>their</emphasis> intended parent-modules so that one
	can put them on top of any other module. Here is an example of
	the construction of a hierarchy for a user-defined ring-type
	<type>MyRing</type>. This hierarchy will support fast
	matrix-multiplication but use <type>GenericModule</type> for
	everything else:
      </para>

      <programlisting>
struct AllModules&lt;MyRing&gt; : public StrassenModule&lt;MyRing, GenericModule&lt;MyRing&gt; &gt;
{
	struct Tag { typedef typename StrassenModule&lt;MyRing, GenericModule&lt;MyRing&gt; &gt;::Tag Parent; };

	AllModules (const MyRing &amp;R) : StrassenModule&lt;MyRing, GenericModule&lt;MyRing&gt; &gt; (R) {}
};</programlisting>
    </section>
  </section>
</article>
